<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VonMesser Virtual Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #galleryContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        .gallery-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .gallery-info {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px 25px;
            border-radius: 12px;
            font-size: 14px;
            color: #333;
            max-width: 350px;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .gallery-info h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            color: #666;
        }

        .artwork-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            color: #333;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            min-width: 200px;
        }

        .artwork-label.visible {
            opacity: 1;
        }

        .artwork-title {
            font-weight: 500;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .artwork-details {
            color: #666;
            font-size: 11px;
            line-height: 1.4;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .view-mode-toggle {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            color: #333;
            pointer-events: auto;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        }

        .view-mode-toggle:hover {
            background: rgba(51, 51, 51, 0.95);
            color: white;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        .gallery-entrance {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 11px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 5px;
            max-width: 300px;
            word-wrap: break-word;
        }

        @media (max-width: 768px) {
            .gallery-info,
            .controls,
            .view-mode-toggle,
            .gallery-entrance {
                font-size: 10px;
                padding: 12px 15px;
            }
            
            .gallery-info {
                max-width: 280px;
            }
        }
    </style>
</head>
<body>
    <div id="galleryContainer">
        <div class="loading" id="loadingText">
            LOADING GALLERY...<br>
            <small id="loadingStatus">Initializing...</small>
        </div>
        
        <div class="debug-info" id="debugInfo">Starting...</div>
        
        <div class="gallery-ui">
            <div class="gallery-info">
                <h3>VonMesser Collection</h3>
                <p>Walk through a curated selection of contemporary and classical works. Each piece is displayed at its actual size based on the collection's metadata.</p>
            </div>
            
            <button class="view-mode-toggle" onclick="toggleView()">Aerial View</button>
            
            <div class="controls">
                <div>WASD or Arrow Keys: Move</div>
                <div>Drag Mouse: Look Around</div>
                <div>Click Artwork: Focus View</div>
            </div>
            
            <div class="gallery-entrance">
                <div>Gallery Walk Mode</div>
                <div style="margin-top: 4px; color: #999;">Real-scale display</div>
            </div>
        </div>
        
        <div class="artwork-label" id="artworkLabel">
            <div class="artwork-title" id="labelTitle"></div>
            <div class="artwork-details" id="labelDetails"></div>
        </div>
    </div>

    <script>
        // Debug logging
        console.log('ðŸŽ¨ VonMesser Virtual Gallery - Script Starting...');
        
        function updateDebug(message) {
            console.log('DEBUG:', message);
            const debugEl = document.getElementById('debugInfo');
            if (debugEl) {
                debugEl.textContent = message;
            }
        }

        function updateStatus(message) {
            console.log('STATUS:', message);
            const statusEl = document.getElementById('loadingStatus');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        updateDebug('Script loaded');
        updateStatus('Script loaded');

        // Global variables
        let scene, camera, renderer;
        let artworksData = [];
        let artworkMeshes = [];
        let raycaster, mouse;
        let isAerialView = false;
        let frameCount = 0;

        // Movement controls
        const keys = {};
        const velocity = { x: 0, y: 0, z: 0 };
        const moveSpeed = 0.15;
        
        // Mouse look controls
        let yaw = 0;
        let pitch = 0;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isMouseDown = false;
        const mouseSensitivity = 0.003;

        // Gallery dimensions (in meters)
        const galleryWidth = 40;
        const galleryDepth = 60;
        const galleryHeight = 6;

        // Demo artworks - always available
        const demoArtworks = [
            {
                id: 'demo-1',
                title: 'Abstract Composition',
                artist: 'Contemporary Artist',
                year: '2024',
                dimensions: '24 Ã— 36 in',
                medium: 'Oil on canvas',
                orientation: 'landscape'
            },
            {
                id: 'demo-2',
                title: 'Modern Landscape',
                artist: 'Gallery Artist',
                year: '2023',
                dimensions: '30 Ã— 40 in',
                medium: 'Acrylic on canvas',
                orientation: 'landscape'
            },
            {
                id: 'demo-3',
                title: 'Still Life Study',
                artist: 'Studio Artist',
                year: '2024',
                dimensions: '18 Ã— 24 in',
                medium: 'Mixed media',
                orientation: 'portrait'
            },
            {
                id: 'demo-4',
                title: 'Urban Portrait',
                artist: 'City Artist',
                year: '2023',
                dimensions: '20 Ã— 30 in',
                medium: 'Digital print',
                orientation: 'portrait'
            },
            {
                id: 'demo-5',
                title: 'Geometric Study',
                artist: 'Modern Artist',
                year: '2024',
                dimensions: '36 Ã— 36 in',
                medium: 'Acrylic on canvas',
                orientation: 'square'
            },
            {
                id: 'demo-6',
                title: 'Nature Abstract',
                artist: 'Landscape Artist',
                year: '2023',
                dimensions: '40 Ã— 30 in',
                medium: 'Oil on canvas',
                orientation: 'landscape'
            }
        ];

        // Load Three.js and initialize
        function loadThreeJS() {
            updateStatus('Loading Three.js...');
            updateDebug('Loading Three.js library');
            
            return new Promise((resolve, reject) => {
                if (window.THREE) {
                    updateDebug('Three.js already loaded');
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = () => {
                    updateDebug('Three.js loaded successfully');
                    updateStatus('Three.js loaded');
                    resolve();
                };
                script.onerror = () => {
                    updateDebug('Failed to load Three.js');
                    updateStatus('Failed to load Three.js');
                    reject(new Error('Failed to load Three.js'));
                };
                document.head.appendChild(script);
            });
        }

        function createSimpleTexture(width, height, color1, color2, text) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Add some geometric shapes for interest
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(width * 0.1, height * 0.1, width * 0.3, height * 0.3);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.arc(width * 0.7, height * 0.3, width * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // Add text label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = `${Math.min(width, height) * 0.08}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(text, width / 2, height * 0.7);
            
            return canvas.toDataURL();
        }

        // Load Supabase and try to get real artworks
        async function loadArtworks() {
            updateStatus('Loading your collection...');
            updateDebug('Attempting to load real artworks from database');
            
            try {
                // First try to load Supabase
                await loadSupabaseLibrary();
                
                if (window.supabase) {
                    const supabaseUrl = 'https://qqkshpkbfixeyusqpsou.supabase.co';
                    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFxa3NocGtiZml4ZXl1c3Fwc291Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5Mjc1ODksImV4cCI6MjA2NDUwMzU4OX0.EhAV5EvXDIRPJcp3ipBSqqo6xY6rh8Jghe__XZ4659U';
                    
                    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
                    updateDebug('Supabase client created, querying artworks table');
                    
                    const { data, error } = await supabase
                        .from('artworks')
                        .select('*')
                        .order('display_order', { ascending: true, nullsLast: true })
                        .order('created_at', { ascending: false });

                    if (error) {
                        updateDebug('Supabase query error: ' + error.message);
                        throw error;
                    }

                    if (data && data.length > 0) {
                        updateDebug(`SUCCESS! Loaded ${data.length} real artworks from your collection`);
                        updateStatus(`Loaded ${data.length} artworks from your collection`);
                        artworksData = data;
                        return artworksData;
                    } else {
                        updateDebug('Database query successful but no artworks found');
                        updateStatus('No artworks in database - using demo');
                    }
                } else {
                    updateDebug('Supabase library failed to load');
                    updateStatus('Database unavailable - using demo');
                }
            } catch (error) {
                updateDebug('Database connection failed: ' + error.message);
                updateStatus('Database error - using demo collection');
                console.error('Error loading real artworks:', error);
            }
            
            // Fallback to demo artworks
            updateDebug('Falling back to demo collection');
            const colors = [
                ['#1a365d', '#4299e1'], // Blue
                ['#276749', '#48bb78'], // Green  
                ['#744210', '#ed8936'], // Orange
                ['#553c9a', '#9f7aea'], // Purple
                ['#822727', '#fc8181'], // Red
                ['#2d3748', '#718096']  // Gray
            ];
            
            artworksData = demoArtworks.map((artwork, index) => ({
                ...artwork,
                images: [createSimpleTexture(512, 384, 
                    colors[index][0],
                    colors[index][1], 
                    artwork.title
                )]
            }));
            
            updateDebug(`Created ${artworksData.length} demo artworks`);
            updateStatus('Demo collection loaded');
            return artworksData;
        }

        function loadSupabaseLibrary() {
            return new Promise((resolve, reject) => {
                if (window.supabase) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
                script.onload = () => {
                    updateDebug('Supabase library loaded successfully');
                    resolve();
                };
                script.onerror = () => {
                    updateDebug('Failed to load Supabase library');
                    reject(new Error('Failed to load Supabase library'));
                };
                document.head.appendChild(script);
            });
        }

        function parseDimensions(dimensionString) {
            const match = dimensionString.match(/([\d.]+)\s*[Ã—x]\s*([\d.]+)\s*(in|cm)/i);
            if (!match) return { width: 1, height: 1 };

            let width = parseFloat(match[1]);
            let height = parseFloat(match[2]);
            const unit = match[3].toLowerCase();

            if (unit === 'in') {
                width *= 0.0254;
                height *= 0.0254;
            } else if (unit === 'cm') {
                width *= 0.01;
                height *= 0.01;
            }

            return { width, height };
        }

        async function initGallery() {
            try {
                updateStatus('Initializing gallery...');
                updateDebug('Starting gallery initialization');

                // Check if Three.js is available
                if (!window.THREE) {
                    throw new Error('Three.js not available');
                }

                const THREE = window.THREE;
                updateDebug('Three.js available, creating scene');

                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111111);

                // Camera setup - start closer to the back wall to see artworks
                camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 10); // Closer to back wall
                camera.lookAt(0, 2, -galleryDepth / 2); // Look at back wall where artworks are

                updateDebug('Camera created');

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                const container = document.getElementById('galleryContainer');
                container.appendChild(renderer.domElement);

                updateDebug('Renderer created and added to DOM');

                // Raycaster for interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                updateDebug('Raycaster created');

                // Create gallery space
                createGallery(THREE);
                updateDebug('Gallery space created');

                // Create lighting
                createLighting(THREE);
                updateDebug('Lighting created');

                // Place artworks
                await placeArtworks(THREE);
                updateDebug('Artworks placed');

                // Setup event listeners
                setupEventListeners();
                updateDebug('Event listeners setup');

                // Hide loading screen
                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
                
                updateStatus('Gallery ready!');
                updateDebug('Gallery initialization complete');

                // Start render loop
                animate();

            } catch (error) {
                updateDebug('Error in initGallery: ' + error.message);
                updateStatus('Error: ' + error.message);
                console.error('Gallery initialization error:', error);
                
                // Show fallback message
                document.getElementById('loadingText').innerHTML = `
                    <div style="color: #ff6b6b;">Gallery failed to load</div>
                    <small>Error: ${error.message}</small><br>
                    <small>Please refresh the page</small>
                `;
            }
        }

        function createGallery(THREE) {
            const galleryGroup = new THREE.Group();

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(galleryWidth, galleryDepth);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xf8f8f8,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            galleryGroup.add(floor);

            // Ceiling
            const ceiling = floor.clone();
            ceiling.position.y = galleryHeight;
            ceiling.rotation.x = Math.PI / 2;
            galleryGroup.add(ceiling);

            // Walls
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.95
            });

            // Back wall
            const backWallGeometry = new THREE.PlaneGeometry(galleryWidth, galleryHeight);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, galleryHeight / 2, -galleryDepth / 2);
            backWall.receiveShadow = true;
            galleryGroup.add(backWall);

            // Left wall
            const leftWallGeometry = new THREE.PlaneGeometry(galleryDepth, galleryHeight);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-galleryWidth / 2, galleryHeight / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            galleryGroup.add(leftWall);

            // Right wall
            const rightWall = leftWall.clone();
            rightWall.position.x = galleryWidth / 2;
            rightWall.rotation.y = -Math.PI / 2;
            galleryGroup.add(rightWall);

            scene.add(galleryGroup);
        }

        function createLighting(THREE) {
            // Brighter ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Main directional light - brighter
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(0, galleryHeight - 1, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Additional front lighting to illuminate artworks
            const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
            frontLight.position.set(0, galleryHeight / 2, galleryDepth / 2);
            frontLight.target.position.set(0, galleryHeight / 2, -galleryDepth / 2);
            scene.add(frontLight);
            scene.add(frontLight.target);

            // Track lighting for artworks - brighter
            for (let i = 0; i < 6; i++) {
                const spotLight = new THREE.SpotLight(0xffffff, 0.8, 20, Math.PI / 4, 0.2);
                spotLight.position.set(
                    (i % 3 - 1) * 8, 
                    galleryHeight - 0.5, 
                    Math.floor(i / 3) * 15 - 10
                );
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 512;
                spotLight.shadow.mapSize.height = 512;
                scene.add(spotLight);
            }
            
            updateDebug('Enhanced lighting created');
        }

        async function placeArtworks(THREE) {
            const wallPositions = [
                // Back wall - more spread out and visible
                { x: -10, y: 2, z: -galleryDepth / 2 + 0.5, rotation: 0 },
                { x: 0, y: 2, z: -galleryDepth / 2 + 0.5, rotation: 0 },
                { x: 10, y: 2, z: -galleryDepth / 2 + 0.5, rotation: 0 },
                // Left wall
                { x: -galleryWidth / 2 + 0.5, y: 2, z: -10, rotation: Math.PI / 2 },
                { x: -galleryWidth / 2 + 0.5, y: 2, z: 10, rotation: Math.PI / 2 },
                // Right wall  
                { x: galleryWidth / 2 - 0.5, y: 2, z: 0, rotation: -Math.PI / 2 }
            ];

            artworksData.forEach((artwork, index) => {
                if (index >= wallPositions.length) return;

                const position = wallPositions[index];
                const dimensions = parseDimensions(artwork.dimensions || '24 Ã— 36 in');
                
                updateDebug(`Placing artwork ${index + 1}: ${artwork.title} by ${artwork.artist}`);
                
                // Make sure dimensions are reasonable
                const minSize = 0.5;
                const maxSize = 3;
                const width = Math.max(minSize, Math.min(maxSize, dimensions.width));
                const height = Math.max(minSize, Math.min(maxSize, dimensions.height));
                
                const geometry = new THREE.PlaneGeometry(width, height);
                
                let material;
                
                // Try to use real artwork image first
                if (artwork.images && artwork.images.length > 0 && artwork.images[0]) {
                    try {
                        updateDebug(`Loading real image for: ${artwork.title}`);
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(
                            artwork.images[0],
                            function(tex) {
                                updateDebug(`âœ… Real artwork texture loaded: ${artwork.title}`);
                                tex.minFilter = THREE.LinearFilter;
                                tex.magFilter = THREE.LinearFilter;
                            },
                            function(progress) {
                                // Loading progress
                            },
                            function(error) {
                                updateDebug(`âŒ Failed to load real texture for ${artwork.title}: ${error}`);
                            }
                        );
                        
                        material = new THREE.MeshLambertMaterial({ 
                            map: texture,
                            transparent: false,
                            side: THREE.FrontSide
                        });
                        
                        updateDebug(`Created material with real image for: ${artwork.title}`);
                        
                    } catch (error) {
                        updateDebug(`Error creating real texture material for ${artwork.title}: ${error.message}`);
                        // Fallback to solid color
                        const colors = [0x4299e1, 0x48bb78, 0xed8936, 0x9f7aea, 0xfc8181, 0x718096];
                        material = new THREE.MeshLambertMaterial({ 
                            color: colors[index % colors.length],
                            transparent: false
                        });
                    }
                } else {
                    // Fallback material with bright color for demo artworks
                    updateDebug(`No real image available for: ${artwork.title} - using fallback color`);
                    const colors = [0x4299e1, 0x48bb78, 0xed8936, 0x9f7aea, 0xfc8181, 0x718096];
                    material = new THREE.MeshLambertMaterial({ 
                        color: colors[index % colors.length],
                        transparent: false
                    });
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(position.x, position.y, position.z);
                mesh.rotation.y = position.rotation;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = artwork;
                
                scene.add(mesh);
                artworkMeshes.push(mesh);
                
                updateDebug(`âœ… Added artwork mesh: "${artwork.title}" by ${artwork.artist} at (${position.x}, ${position.y}, ${position.z})`);

                // Create a more visible frame
                const frameGeometry = new THREE.PlaneGeometry(width + 0.2, height + 0.2);
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1a202c,
                    transparent: false
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(position.x, position.y, position.z - 0.01);
                frame.rotation.y = position.rotation;
                frame.receiveShadow = true;
                
                scene.add(frame);
            });
            
            updateDebug(`ðŸŽ¨ Gallery complete! Total artworks placed: ${artworkMeshes.length}`);
            
            // Summary of what was loaded
            const realArtworks = artworksData.filter(a => a.images && a.images.length > 0 && !a.id.includes('demo'));
            const demoArtworks = artworksData.filter(a => a.id.includes('demo'));
            
            updateDebug(`ðŸ“Š Collection summary: ${realArtworks.length} real artworks, ${demoArtworks.length} demo pieces`);
        }

        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);

            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Prevent context menu
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            if (isAerialView) return;
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            renderer.domElement.style.cursor = 'grabbing';
        }

        function onMouseUp(event) {
            isMouseDown = false;
            renderer.domElement.style.cursor = 'crosshair';
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(artworkMeshes);

            if (intersects.length > 0) {
                const artwork = intersects[0].object.userData;
                focusOnArtwork(intersects[0].object, artwork);
            }
        }

        function onMouseMove(event) {
            if (isAerialView) return;

            const currentMouseX = event.clientX;
            const currentMouseY = event.clientY;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(artworkMeshes);

            const label = document.getElementById('artworkLabel');
            
            if (intersects.length > 0) {
                const artwork = intersects[0].object.userData;
                showArtworkLabel(artwork, event.clientX, event.clientY);
            } else {
                label.classList.remove('visible');
            }

            if (isMouseDown) {
                const deltaX = currentMouseX - lastMouseX;
                const deltaY = currentMouseY - lastMouseY;

                yaw -= deltaX * mouseSensitivity;
                pitch -= deltaY * mouseSensitivity;
                
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
                camera.rotation.z = 0;
            }

            lastMouseX = currentMouseX;
            lastMouseY = currentMouseY;
        }

        function showArtworkLabel(artwork, x, y) {
            const label = document.getElementById('artworkLabel');
            document.getElementById('labelTitle').textContent = artwork.title;
            document.getElementById('labelDetails').innerHTML = `
                ${artwork.artist}, ${artwork.year}<br>
                ${artwork.dimensions}<br>
                <em style="color: #999;">${artwork.medium}</em>
            `;
            
            label.style.left = (x + 15) + 'px';
            label.style.top = (y - 60) + 'px';
            label.classList.add('visible');
        }

        function focusOnArtwork(mesh, artwork) {
            const targetPosition = mesh.position.clone();
            const box = new (window.THREE.Box3)().setFromObject(mesh);
            const size = box.getSize(new window.THREE.Vector3());
            const distance = Math.max(size.x, size.y) * 1.5 + 2;
            
            const normal = new window.THREE.Vector3(0, 0, 1);
            normal.applyEuler(mesh.rotation);
            const cameraPosition = targetPosition.clone().add(normal.multiplyScalar(distance));
            cameraPosition.y = Math.max(1.6, targetPosition.y);
            
            animateCamera(cameraPosition, targetPosition);
        }

        function animateCamera(targetPosition, lookAtPosition) {
            const startPosition = camera.position.clone();
            const startQuaternion = camera.quaternion.clone();
            
            const tempCamera = camera.clone();
            tempCamera.position.copy(targetPosition);
            tempCamera.lookAt(lookAtPosition);
            const targetQuaternion = tempCamera.quaternion.clone();
            
            const duration = 1500;
            const startTime = Date.now();
            
            function animateStep() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, eased);
                camera.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                }
            }
            
            animateStep();
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function updateMovement() {
            if (isAerialView) return;

            velocity.x = 0;
            velocity.z = 0;

            const forward = { x: Math.sin(yaw), z: Math.cos(yaw) };
            const right = { x: Math.cos(yaw), z: -Math.sin(yaw) };

            if (keys['KeyW'] || keys['ArrowUp']) {
                velocity.x += forward.x * -moveSpeed;
                velocity.z += forward.z * -moveSpeed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                velocity.x += forward.x * moveSpeed;
                velocity.z += forward.z * moveSpeed;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                velocity.x += right.x * -moveSpeed;
                velocity.z += right.z * -moveSpeed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                velocity.x += right.x * moveSpeed;
                velocity.z += right.z * moveSpeed;
            }

            const newPosition = {
                x: camera.position.x + velocity.x,
                y: camera.position.y,
                z: camera.position.z + velocity.z
            };
            
            const margin = 2;
            newPosition.x = Math.max(-galleryWidth/2 + margin, Math.min(galleryWidth/2 - margin, newPosition.x));
            newPosition.z = Math.max(-galleryDepth/2 + margin, Math.min(galleryDepth/2 - margin, newPosition.z));
            
            camera.position.set(newPosition.x, newPosition.y, newPosition.z);
        }

        function toggleView() {
            isAerialView = !isAerialView;
            const button = document.querySelector('.view-mode-toggle');
            
            if (isAerialView) {
                camera.position.set(0, galleryHeight + 15, 0);
                camera.lookAt(0, 0, 0);
                camera.rotation.order = 'XYZ';
                camera.rotation.x = -Math.PI / 2;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                button.textContent = 'Walk Mode';
                isMouseDown = false;
                renderer.domElement.style.cursor = 'default';
            } else {
                camera.position.set(0, 1.6, 15);
                yaw = 0;
                pitch = 0;
                camera.rotation.order = 'YXZ';
                camera.rotation.x = 0;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                camera.lookAt(0, 1.6, 0);
                button.textContent = 'Aerial View';
                renderer.domElement.style.cursor = 'crosshair';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            updateMovement();
            renderer.render(scene, camera);
        }

        // Main initialization function
        async function startGallery() {
            try {
                updateDebug('Starting gallery initialization');
                
                // Load Three.js
                await loadThreeJS();
                updateDebug('Three.js loaded');
                
                // Load artworks
                await loadArtworks();
                updateDebug('Artworks loaded');
                
                // Initialize gallery
                await initGallery();
                updateDebug('Gallery initialized');
                
            } catch (error) {
                updateDebug('Failed to start gallery: ' + error.message);
                updateStatus('Gallery failed to start');
                console.error('Gallery startup error:', error);
                
                document.getElementById('loadingText').innerHTML = `
                    <div style="color: #ff6b6b;">Gallery Error</div>
                    <small>${error.message}</small><br>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Reload Page
                    </button>
                `;
            }
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGallery);
        } else {
            startGallery();
        }

        // Fallback timer
        setTimeout(() => {
            if (!renderer) {
                updateDebug('Timeout reached, gallery not loaded');
                updateStatus('Timeout - please reload');
                document.getElementById('loadingText').innerHTML = `
                    <div style="color: #ff6b6b;">Gallery Timeout</div>
                    <small>Please refresh the page</small><br>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Reload Page
                    </button>
                `;
            }
        }, 15000);

        console.log('ðŸŽ¨ Gallery script setup complete');
    </script>
</body>
</html>
